//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;

using static PhotoSauce.MagicScaler.MathUtil;

namespace PhotoSauce.MagicScaler
{
	unsafe internal class ConvolverBgra8bpc : IConvolver8bpc
	{
		private const int Channels = 4;

		void IConvolver8bpc.ConvolveSourceLine(byte* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* pmapxa = mapxastart + 1;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0, a1 = 0, a2 = 0, a3 = 0, aw = 0;

				int ix = *pmapx++;
				byte* ip = istart + ix * Channels + 4 * Channels;
				byte* ipe = ip + smapx * Channels - 3 * Channels;
				int* mp = pmapx + 4, mpa = pmapxa + 4;
				pmapx += smapx;
				pmapxa += smapx + 1;

				while (ip < ipe)
				{
					int alpha = ip[-13];
					if (alpha == 0)
					{
						aw += mp[-4];
					}
					else
					{
						int w = mp[-4];
						a0 += ip[-16] * w;
						a1 += ip[-15] * w;
						a2 += ip[-14] * w;
						a3 += alpha * mpa[-4];
					}

					alpha = ip[-9];
					if (alpha == 0)
					{
						aw += mp[-3];
					}
					else
					{
						int w = mp[-3];
						a0 += ip[-12] * w;
						a1 += ip[-11] * w;
						a2 += ip[-10] * w;
						a3 += alpha * mpa[-3];
					}

					alpha = ip[-5];
					if (alpha == 0)
					{
						aw += mp[-2];
					}
					else
					{
						int w = mp[-2];
						a0 += ip[-8] * w;
						a1 += ip[-7] * w;
						a2 += ip[-6] * w;
						a3 += alpha * mpa[-2];
					}

					alpha = ip[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += ip[-4] * w;
						a1 += ip[-3] * w;
						a2 += ip[-2] * w;
						a3 += alpha * mpa[-1];
					}

					ip += 4 * Channels;
					mp += 4;
					mpa+= 4;
				}

				ip -= 3 * Channels;
				mp -= 3;
				mpa-= 3;
				while (ip < ipe)
				{
					int alpha = ip[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += ip[-4] * w;
						a1 += ip[-3] * w;
						a2 += ip[-2] * w;
						a3 += alpha * mpa[-1];
					}

					ip += Channels;
					mp++;
					mpa++;
				}

				if (aw != 0)
				{
					float wf = UnscaleToFloat(aw);
					wf = 1f / (1f - wf);
					a0 = (int)(a0 * wf);
					a1 = (int)(a1 * wf);
					a2 = (int)(a2 * wf);
				}

				tp[0] = UnscaleToInt32(a0);
				tp[1] = UnscaleToInt32(a1);
				tp[2] = UnscaleToInt32(a2);
				tp[3] = UnscaleToInt32(a3);
				tp += tstride;
			}
		}

		void IConvolver8bpc.WriteDestLine(int* tstart, int tstride, byte* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			byte* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0, a1 = 0, a2 = 0, a3 = 0, aw = 0;

				int* tp = tstart + ox * tstride + 2 * Channels;
				int* tpe = tp + tstride - 1 * Channels;
				int* mp = pmapy + 2, mpa = pmapya + 2;

				while (tp < tpe)
				{
					int alpha = tp[-5];
					if (alpha == 0)
					{
						aw += mp[-2];
					}
					else
					{
						int w = mp[-2];
						a0 += tp[-8] * w;
						a1 += tp[-7] * w;
						a2 += tp[-6] * w;
						a3 += alpha * mpa[-2];
					}

					alpha = tp[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += tp[-4] * w;
						a1 += tp[-3] * w;
						a2 += tp[-2] * w;
						a3 += alpha * mpa[-1];
					}

					tp += 2 * Channels;
					mp += 2;
					mpa+= 2;
				}

				tp -= 1 * Channels;
				mp -= 1;
				mpa-= 1;
				while (tp < tpe)
				{
					int alpha = tp[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += tp[-4] * w;
						a1 += tp[-3] * w;
						a2 += tp[-2] * w;
						a3 += alpha * mpa[-1];
					}

					tp += Channels;
					mp++;
					mpa++;
				}

				if (a3 <= 0)
				{
					a0 = a1 = a2 = a3 = 0;
				}
				else if (aw != 0)
				{
					float wf = UnscaleToFloat(aw);
					wf = 1f / (1f - wf);
					a0 = (int)(a0 * wf);
					a1 = (int)(a1 * wf);
					a2 = (int)(a2 * wf);
				}

				op[0] = UnscaleToByte(a0);
				op[1] = UnscaleToByte(a1);
				op[2] = UnscaleToByte(a2);
				op[3] = UnscaleToByte(a3);
				op += Channels;
				ox++;
			}
		}

		void IConvolver8bpc.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh)
		{
			int iamt = ScaleToInt32(amt / 100d);
			int threshold = thresh;

			byte* ip = cstart, bp = bstart, op = ostart;
			int xc = ox + ow;

			for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
			{
				byte c0 = ip[0], c1 = ip[1], c2 = ip[2], c3 = ip[3];
				int yi = LumaFromBgr(c0, c1, c2);
				int yb = LumaFromBgr(bp[0], bp[1], bp[2]);
				if (threshold == 0 || Math.Abs(yi - yb) > threshold)
				{
					int dif = UnscaleToInt32((yi - yb) * iamt);
					op[0] = ClampToByte(c0 + dif);
					op[1] = ClampToByte(c1 + dif);
					op[2] = ClampToByte(c2 + dif);
					op[3] = c3;
				}
				else
				{
					op[0] = c0;
					op[1] = c1;
					op[2] = c2;
					op[3] = c3;
				}
			}
		}
	}

	unsafe internal class ConvolverBgra16bpc : IConvolver16bpc
	{
		private const int Channels = 4;

		void IConvolver16bpc.ConvolveSourceLine(ushort* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* pmapxa = mapxastart + 1;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0, a1 = 0, a2 = 0, a3 = 0, aw = 0;

				int ix = *pmapx++;
				ushort* ip = istart + ix * Channels + 4 * Channels;
				ushort* ipe = ip + smapx * Channels - 3 * Channels;
				int* mp = pmapx + 4, mpa = pmapxa + 4;
				pmapx += smapx;
				pmapxa += smapx + 1;

				while (ip < ipe)
				{
					int alpha = ip[-13];
					if (alpha == 0)
					{
						aw += mp[-4];
					}
					else
					{
						int w = mp[-4];
						a0 += ip[-16] * w;
						a1 += ip[-15] * w;
						a2 += ip[-14] * w;
						a3 += alpha * mpa[-4];
					}

					alpha = ip[-9];
					if (alpha == 0)
					{
						aw += mp[-3];
					}
					else
					{
						int w = mp[-3];
						a0 += ip[-12] * w;
						a1 += ip[-11] * w;
						a2 += ip[-10] * w;
						a3 += alpha * mpa[-3];
					}

					alpha = ip[-5];
					if (alpha == 0)
					{
						aw += mp[-2];
					}
					else
					{
						int w = mp[-2];
						a0 += ip[-8] * w;
						a1 += ip[-7] * w;
						a2 += ip[-6] * w;
						a3 += alpha * mpa[-2];
					}

					alpha = ip[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += ip[-4] * w;
						a1 += ip[-3] * w;
						a2 += ip[-2] * w;
						a3 += alpha * mpa[-1];
					}

					ip += 4 * Channels;
					mp += 4;
					mpa+= 4;
				}

				ip -= 3 * Channels;
				mp -= 3;
				mpa-= 3;
				while (ip < ipe)
				{
					int alpha = ip[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += ip[-4] * w;
						a1 += ip[-3] * w;
						a2 += ip[-2] * w;
						a3 += alpha * mpa[-1];
					}

					ip += Channels;
					mp++;
					mpa++;
				}

				if (aw != 0)
				{
					float wf = UnscaleToFloat(aw);
					wf = 1f / (1f - wf);
					a0 = (int)(a0 * wf);
					a1 = (int)(a1 * wf);
					a2 = (int)(a2 * wf);
				}

				tp[0] = UnscaleToInt32(a0);
				tp[1] = UnscaleToInt32(a1);
				tp[2] = UnscaleToInt32(a2);
				tp[3] = UnscaleToInt32(a3);
				tp += tstride;
			}
		}

		void IConvolver16bpc.WriteDestLine(int* tstart, int tstride, ushort* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			ushort* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0, a1 = 0, a2 = 0, a3 = 0, aw = 0;

				int* tp = tstart + ox * tstride + 2 * Channels;
				int* tpe = tp + tstride - 1 * Channels;
				int* mp = pmapy + 2, mpa = pmapya + 2;

				while (tp < tpe)
				{
					int alpha = tp[-5];
					if (alpha == 0)
					{
						aw += mp[-2];
					}
					else
					{
						int w = mp[-2];
						a0 += tp[-8] * w;
						a1 += tp[-7] * w;
						a2 += tp[-6] * w;
						a3 += alpha * mpa[-2];
					}

					alpha = tp[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += tp[-4] * w;
						a1 += tp[-3] * w;
						a2 += tp[-2] * w;
						a3 += alpha * mpa[-1];
					}

					tp += 2 * Channels;
					mp += 2;
					mpa+= 2;
				}

				tp -= 1 * Channels;
				mp -= 1;
				mpa-= 1;
				while (tp < tpe)
				{
					int alpha = tp[-1];
					if (alpha == 0)
					{
						aw += mp[-1];
					}
					else
					{
						int w = mp[-1];
						a0 += tp[-4] * w;
						a1 += tp[-3] * w;
						a2 += tp[-2] * w;
						a3 += alpha * mpa[-1];
					}

					tp += Channels;
					mp++;
					mpa++;
				}

				if (a3 <= 0)
				{
					a0 = a1 = a2 = a3 = 0;
				}
				else if (aw != 0)
				{
					float wf = UnscaleToFloat(aw);
					wf = 1f / (1f - wf);
					a0 = (int)(a0 * wf);
					a1 = (int)(a1 * wf);
					a2 = (int)(a2 * wf);
				}

				op[0] = UnscaleToUInt15(a0);
				op[1] = UnscaleToUInt15(a1);
				op[2] = UnscaleToUInt15(a2);
				op[3] = UnscaleToUInt15(a3);
				op += Channels;
				ox++;
			}
		}

		void IConvolver16bpc.SharpenLine(ushort* cstart, ushort* bstart, ushort* ostart, int ox, int ow, int amt, int thresh)
		{
			fixed (byte* gt = LookupTables.Gamma)
			{
				int iamt = ScaleToInt32(amt / 100d);
				int threshold = thresh;
	
				ushort* ip = cstart, bp = bstart, op = ostart;
				int xc = ox + ow;
	
				for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
				{
					ushort c0 = ip[0], c1 = ip[1], c2 = ip[2], c3 = ip[3];
					int yi = LumaFromBgr(c0, c1, c2);
					int yb = LumaFromBgr(bp[0], bp[1], bp[2]);
					if (threshold == 0 || Math.Abs(gt[yi] - gt[yb]) > threshold)
					{
						int dif = UnscaleToInt32((yi - yb) * iamt);
						op[0] = ClampToUInt15(c0 + dif);
						op[1] = ClampToUInt15(c1 + dif);
						op[2] = ClampToUInt15(c2 + dif);
						op[3] = c3;
					}
					else
					{
						op[0] = c0;
						op[1] = c1;
						op[2] = c2;
						op[3] = c3;
					}
				}
			}
		}
	}

	unsafe internal class ConvolverBgr8bpc : IConvolver8bpc
	{
		private const int Channels = 3;

		void IConvolver8bpc.ConvolveSourceLine(byte* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0, a1 = 0, a2 = 0;

				int ix = *pmapx++;
				byte* ip = istart + ix * Channels + 5 * Channels;
				byte* ipe = ip + smapx * Channels - 4 * Channels;
				int* mp = pmapx + 5;
				pmapx += smapx;

				while (ip < ipe)
				{
					int w = mp[-5];
					a0 += ip[-15] * w;
					a1 += ip[-14] * w;
					a2 += ip[-13] * w;

					w = mp[-4];
					a0 += ip[-12] * w;
					a1 += ip[-11] * w;
					a2 += ip[-10] * w;

					w = mp[-3];
					a0 += ip[-9] * w;
					a1 += ip[-8] * w;
					a2 += ip[-7] * w;

					w = mp[-2];
					a0 += ip[-6] * w;
					a1 += ip[-5] * w;
					a2 += ip[-4] * w;

					w = mp[-1];
					a0 += ip[-3] * w;
					a1 += ip[-2] * w;
					a2 += ip[-1] * w;

					ip += 5 * Channels;
					mp += 5;
				}

				ip -= 4 * Channels;
				mp -= 4;
				while (ip < ipe)
				{
					int w = mp[-1];
					a0 += ip[-3] * w;
					a1 += ip[-2] * w;
					a2 += ip[-1] * w;

					ip += Channels;
					mp++;
				}

				tp[0] = UnscaleToInt32(a0);
				tp[1] = UnscaleToInt32(a1);
				tp[2] = UnscaleToInt32(a2);
				tp += tstride;
			}
		}

		void IConvolver8bpc.WriteDestLine(int* tstart, int tstride, byte* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			byte* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0, a1 = 0, a2 = 0;

				int* tp = tstart + ox * tstride + 2 * Channels;
				int* tpe = tp + tstride - 1 * Channels;
				int* mp = pmapy + 2;

				while (tp < tpe)
				{
					int w = mp[-2];
					a0 += tp[-6] * w;
					a1 += tp[-5] * w;
					a2 += tp[-4] * w;

					w = mp[-1];
					a0 += tp[-3] * w;
					a1 += tp[-2] * w;
					a2 += tp[-1] * w;

					tp += 2 * Channels;
					mp += 2;
				}

				tp -= 1 * Channels;
				mp -= 1;
				while (tp < tpe)
				{
					int w = mp[-1];
					a0 += tp[-3] * w;
					a1 += tp[-2] * w;
					a2 += tp[-1] * w;

					tp += Channels;
					mp++;
				}

				op[0] = UnscaleToByte(a0);
				op[1] = UnscaleToByte(a1);
				op[2] = UnscaleToByte(a2);
				op += Channels;
				ox++;
			}
		}

		void IConvolver8bpc.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh)
		{
			int iamt = ScaleToInt32(amt / 100d);
			int threshold = thresh;

			byte* ip = cstart, bp = bstart, op = ostart;
			int xc = ox + ow;

			for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
			{
				byte c0 = ip[0], c1 = ip[1], c2 = ip[2];
				int yi = LumaFromBgr(c0, c1, c2);
				int yb = LumaFromBgr(bp[0], bp[1], bp[2]);
				if (threshold == 0 || Math.Abs(yi - yb) > threshold)
				{
					int dif = UnscaleToInt32((yi - yb) * iamt);
					op[0] = ClampToByte(c0 + dif);
					op[1] = ClampToByte(c1 + dif);
					op[2] = ClampToByte(c2 + dif);
				}
				else
				{
					op[0] = c0;
					op[1] = c1;
					op[2] = c2;
				}
			}
		}
	}

	unsafe internal class ConvolverBgr16bpc : IConvolver16bpc
	{
		private const int Channels = 3;

		void IConvolver16bpc.ConvolveSourceLine(ushort* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0, a1 = 0, a2 = 0;

				int ix = *pmapx++;
				ushort* ip = istart + ix * Channels + 5 * Channels;
				ushort* ipe = ip + smapx * Channels - 4 * Channels;
				int* mp = pmapx + 5;
				pmapx += smapx;

				while (ip < ipe)
				{
					int w = mp[-5];
					a0 += ip[-15] * w;
					a1 += ip[-14] * w;
					a2 += ip[-13] * w;

					w = mp[-4];
					a0 += ip[-12] * w;
					a1 += ip[-11] * w;
					a2 += ip[-10] * w;

					w = mp[-3];
					a0 += ip[-9] * w;
					a1 += ip[-8] * w;
					a2 += ip[-7] * w;

					w = mp[-2];
					a0 += ip[-6] * w;
					a1 += ip[-5] * w;
					a2 += ip[-4] * w;

					w = mp[-1];
					a0 += ip[-3] * w;
					a1 += ip[-2] * w;
					a2 += ip[-1] * w;

					ip += 5 * Channels;
					mp += 5;
				}

				ip -= 4 * Channels;
				mp -= 4;
				while (ip < ipe)
				{
					int w = mp[-1];
					a0 += ip[-3] * w;
					a1 += ip[-2] * w;
					a2 += ip[-1] * w;

					ip += Channels;
					mp++;
				}

				tp[0] = UnscaleToInt32(a0);
				tp[1] = UnscaleToInt32(a1);
				tp[2] = UnscaleToInt32(a2);
				tp += tstride;
			}
		}

		void IConvolver16bpc.WriteDestLine(int* tstart, int tstride, ushort* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			ushort* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0, a1 = 0, a2 = 0;

				int* tp = tstart + ox * tstride + 2 * Channels;
				int* tpe = tp + tstride - 1 * Channels;
				int* mp = pmapy + 2;

				while (tp < tpe)
				{
					int w = mp[-2];
					a0 += tp[-6] * w;
					a1 += tp[-5] * w;
					a2 += tp[-4] * w;

					w = mp[-1];
					a0 += tp[-3] * w;
					a1 += tp[-2] * w;
					a2 += tp[-1] * w;

					tp += 2 * Channels;
					mp += 2;
				}

				tp -= 1 * Channels;
				mp -= 1;
				while (tp < tpe)
				{
					int w = mp[-1];
					a0 += tp[-3] * w;
					a1 += tp[-2] * w;
					a2 += tp[-1] * w;

					tp += Channels;
					mp++;
				}

				op[0] = UnscaleToUInt15(a0);
				op[1] = UnscaleToUInt15(a1);
				op[2] = UnscaleToUInt15(a2);
				op += Channels;
				ox++;
			}
		}

		void IConvolver16bpc.SharpenLine(ushort* cstart, ushort* bstart, ushort* ostart, int ox, int ow, int amt, int thresh)
		{
			fixed (byte* gt = LookupTables.Gamma)
			{
				int iamt = ScaleToInt32(amt / 100d);
				int threshold = thresh;
	
				ushort* ip = cstart, bp = bstart, op = ostart;
				int xc = ox + ow;
	
				for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
				{
					ushort c0 = ip[0], c1 = ip[1], c2 = ip[2];
					int yi = LumaFromBgr(c0, c1, c2);
					int yb = LumaFromBgr(bp[0], bp[1], bp[2]);
					if (threshold == 0 || Math.Abs(gt[yi] - gt[yb]) > threshold)
					{
						int dif = UnscaleToInt32((yi - yb) * iamt);
						op[0] = ClampToUInt15(c0 + dif);
						op[1] = ClampToUInt15(c1 + dif);
						op[2] = ClampToUInt15(c2 + dif);
					}
					else
					{
						op[0] = c0;
						op[1] = c1;
						op[2] = c2;
					}
				}
			}
		}
	}

	unsafe internal class ConvolverCbCr8bpc : IConvolver8bpc
	{
		private const int Channels = 2;

		void IConvolver8bpc.ConvolveSourceLine(byte* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0, a1 = 0;

				int ix = *pmapx++;
				byte* ip = istart + ix * Channels + 8 * Channels;
				byte* ipe = ip + smapx * Channels - 7 * Channels;
				int* mp = pmapx + 8;
				pmapx += smapx;

				while (ip < ipe)
				{
					int w = mp[-8];
					a0 += ip[-16] * w;
					a1 += ip[-15] * w;

					w = mp[-7];
					a0 += ip[-14] * w;
					a1 += ip[-13] * w;

					w = mp[-6];
					a0 += ip[-12] * w;
					a1 += ip[-11] * w;

					w = mp[-5];
					a0 += ip[-10] * w;
					a1 += ip[-9] * w;

					w = mp[-4];
					a0 += ip[-8] * w;
					a1 += ip[-7] * w;

					w = mp[-3];
					a0 += ip[-6] * w;
					a1 += ip[-5] * w;

					w = mp[-2];
					a0 += ip[-4] * w;
					a1 += ip[-3] * w;

					w = mp[-1];
					a0 += ip[-2] * w;
					a1 += ip[-1] * w;

					ip += 8 * Channels;
					mp += 8;
				}

				ip -= 7 * Channels;
				mp -= 7;
				while (ip < ipe)
				{
					int w = mp[-1];
					a0 += ip[-2] * w;
					a1 += ip[-1] * w;

					ip += Channels;
					mp++;
				}

				tp[0] = UnscaleToInt32(a0);
				tp[1] = UnscaleToInt32(a1);
				tp += tstride;
			}
		}

		void IConvolver8bpc.WriteDestLine(int* tstart, int tstride, byte* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			byte* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0, a1 = 0;

				int* tp = tstart + ox * tstride + 4 * Channels;
				int* tpe = tp + tstride - 3 * Channels;
				int* mp = pmapy + 4;

				while (tp < tpe)
				{
					int w = mp[-4];
					a0 += tp[-8] * w;
					a1 += tp[-7] * w;

					w = mp[-3];
					a0 += tp[-6] * w;
					a1 += tp[-5] * w;

					w = mp[-2];
					a0 += tp[-4] * w;
					a1 += tp[-3] * w;

					w = mp[-1];
					a0 += tp[-2] * w;
					a1 += tp[-1] * w;

					tp += 4 * Channels;
					mp += 4;
				}

				tp -= 3 * Channels;
				mp -= 3;
				while (tp < tpe)
				{
					int w = mp[-1];
					a0 += tp[-2] * w;
					a1 += tp[-1] * w;

					tp += Channels;
					mp++;
				}

				op[0] = UnscaleToByte(a0);
				op[1] = UnscaleToByte(a1);
				op += Channels;
				ox++;
			}
		}

		void IConvolver8bpc.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh)
		{
			int iamt = ScaleToInt32(amt / 100d);
			int threshold = thresh;

			byte* ip = cstart, bp = bstart, op = ostart;
			int xc = ox + ow;

			for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
			{
				byte c0 = ip[0], c1 = ip[1];
				int yi = c0;
				int yb = bp[0];
				if (threshold == 0 || Math.Abs(yi - yb) > threshold)
				{
					int dif = UnscaleToInt32((yi - yb) * iamt);
					op[0] = ClampToByte(c0 + dif);
					op[1] = ClampToByte(c1 + dif);
				}
				else
				{
					op[0] = c0;
					op[1] = c1;
				}
			}
		}
	}

	unsafe internal class ConvolverGrey8bpc : IConvolver8bpc
	{
		private const int Channels = 1;

		void IConvolver8bpc.ConvolveSourceLine(byte* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0;

				int ix = *pmapx++;
				byte* ip = istart + ix * Channels + 8 * Channels;
				byte* ipe = ip + smapx * Channels - 7 * Channels;
				int* mp = pmapx + 8;
				pmapx += smapx;

				while (ip < ipe)
				{
					a0 += ip[-8] * mp[-8];
					a0 += ip[-7] * mp[-7];
					a0 += ip[-6] * mp[-6];
					a0 += ip[-5] * mp[-5];
					a0 += ip[-4] * mp[-4];
					a0 += ip[-3] * mp[-3];
					a0 += ip[-2] * mp[-2];
					a0 += ip[-1] * mp[-1];
					ip += 8 * Channels;
					mp += 8;
				}

				ip -= 7 * Channels;
				mp -= 7;
				while (ip < ipe)
				{
					a0 += ip[-1] * mp[-1];

					ip += Channels;
					mp++;
				}

				tp[0] = UnscaleToInt32(a0);
				tp += tstride;
			}
		}

		void IConvolver8bpc.WriteDestLine(int* tstart, int tstride, byte* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			byte* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0;

				int* tp = tstart + ox * tstride + 4 * Channels;
				int* tpe = tp + tstride - 3 * Channels;
				int* mp = pmapy + 4;

				while (tp < tpe)
				{
					a0 += tp[-4] * mp[-4];
					a0 += tp[-3] * mp[-3];
					a0 += tp[-2] * mp[-2];
					a0 += tp[-1] * mp[-1];
					tp += 4 * Channels;
					mp += 4;
				}

				tp -= 3 * Channels;
				mp -= 3;
				while (tp < tpe)
				{
					a0 += tp[-1] * mp[-1];

					tp += Channels;
					mp++;
				}

				op[0] = UnscaleToByte(a0);
				op += Channels;
				ox++;
			}
		}

		void IConvolver8bpc.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh)
		{
			int iamt = ScaleToInt32(amt / 100d);
			int threshold = thresh;

			byte* ip = cstart, bp = bstart, op = ostart;
			int xc = ox + ow;

			for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
			{
				byte c0 = ip[0];
				int yi = c0;
				int yb = bp[0];
				if (threshold == 0 || Math.Abs(yi - yb) > threshold)
				{
					int dif = UnscaleToInt32((yi - yb) * iamt);
					op[0] = ClampToByte(c0 + dif);
				}
				else
				{
					op[0] = c0;
				}
			}
		}
	}

	unsafe internal class ConvolverGrey16bpc : IConvolver16bpc
	{
		private const int Channels = 1;

		void IConvolver16bpc.ConvolveSourceLine(ushort* istart, int* tstart, int tstride, int tlen, int* mapxstart, int* mapxastart, int smapx)
		{
			int* pmapx = mapxstart;
			int* tp = tstart;
			int* tpe = tstart + tlen;

			while (tp < tpe)
			{
				int a0 = 0;

				int ix = *pmapx++;
				ushort* ip = istart + ix * Channels + 8 * Channels;
				ushort* ipe = ip + smapx * Channels - 7 * Channels;
				int* mp = pmapx + 8;
				pmapx += smapx;

				while (ip < ipe)
				{
					a0 += ip[-8] * mp[-8];
					a0 += ip[-7] * mp[-7];
					a0 += ip[-6] * mp[-6];
					a0 += ip[-5] * mp[-5];
					a0 += ip[-4] * mp[-4];
					a0 += ip[-3] * mp[-3];
					a0 += ip[-2] * mp[-2];
					a0 += ip[-1] * mp[-1];
					ip += 8 * Channels;
					mp += 8;
				}

				ip -= 7 * Channels;
				mp -= 7;
				while (ip < ipe)
				{
					a0 += ip[-1] * mp[-1];

					ip += Channels;
					mp++;
				}

				tp[0] = UnscaleToInt32(a0);
				tp += tstride;
			}
		}

		void IConvolver16bpc.WriteDestLine(int* tstart, int tstride, ushort* ostart, int ox, int ow, int* pmapy, int* pmapya, int smapy)
		{
			ushort* op = ostart;
			int xc = ox + ow;

			while (ox < xc)
			{
				int a0 = 0;

				int* tp = tstart + ox * tstride + 4 * Channels;
				int* tpe = tp + tstride - 3 * Channels;
				int* mp = pmapy + 4;

				while (tp < tpe)
				{
					a0 += tp[-4] * mp[-4];
					a0 += tp[-3] * mp[-3];
					a0 += tp[-2] * mp[-2];
					a0 += tp[-1] * mp[-1];
					tp += 4 * Channels;
					mp += 4;
				}

				tp -= 3 * Channels;
				mp -= 3;
				while (tp < tpe)
				{
					a0 += tp[-1] * mp[-1];

					tp += Channels;
					mp++;
				}

				op[0] = UnscaleToUInt15(a0);
				op += Channels;
				ox++;
			}
		}

		void IConvolver16bpc.SharpenLine(ushort* cstart, ushort* bstart, ushort* ostart, int ox, int ow, int amt, int thresh)
		{
			fixed (byte* gt = LookupTables.Gamma)
			{
				int iamt = ScaleToInt32(amt / 100d);
				int threshold = thresh;
	
				ushort* ip = cstart, bp = bstart, op = ostart;
				int xc = ox + ow;
	
				for (int x = ox; x < xc; x++, ip += Channels, bp += Channels, op += Channels)
				{
					ushort c0 = ip[0];
					int yi = c0;
					int yb = bp[0];
					if (threshold == 0 || Math.Abs(gt[yi] - gt[yb]) > threshold)
					{
						int dif = UnscaleToInt32((yi - yb) * iamt);
						op[0] = ClampToUInt15(c0 + dif);
					}
					else
					{
						op[0] = c0;
					}
				}
			}
		}
	}

}
